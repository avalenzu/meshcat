<html>
<body>

<div id="svgcat"></div>

<script src="https://rawgit.com/kawanet/msgpack-lite/master/dist/msgpack.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.16.0/d3.min.js"></script>
<!-- <script src="https://unpkg.com/rematrix"></script> -->
<script>
  var svg = d3
    .select("#svgcat")
    .append("svg")
    .attr("width", 600)
    .attr("height", 600)
    .attr("viewBox", `-4 -4 8 8`);

  // World frame's pose in the viewBox 2D frame (column-order)
  // This is a 3x4 view projection matrix. For planar orthographic
  // projection, use:
  //  [ <x axis select> x_axis_shift
  //    <y axis select> y_axis_shift
  //     0, 0, 0, 1]  % homogenizer
  //  e.g.
  //    [ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 1]
  //  would give a top-down view (i.e squashing the z axis), and would shift
  //  things in the x axis positively by 0.5.
  //  X_VW can be any valid view projection matrix. If the bottom row is
  //  [0, 0, 0, 1], the view projection will be an orthographic projection.
  var X_VW = [ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1]
  var tree = {};

  // Multiply 4x4 RigidBodyTransforms (in column-order).
  function multiply_transform3d(X_AB, X_BC) {
    let ma = X_AB
    let mb = X_BC
    let X_AC = []

    // TODO: simply looping through the multiplies should be more efficient.
    for (let i = 0; i < 4; i++) {
      let row = [ma[i], ma[i + 4], ma[i + 8], ma[i + 12]]
      for (let j = 0; j < 4; j++) {
        let k = j * 4
        let col = [mb[k], mb[k + 1], mb[k + 2], mb[k + 3]]
        let result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3]
        X_AC[i + k] = result
      }
    }
    return X_AC
  }

  // Multiplies X_VW * X_WG * pts and homogenizes
  function project_points(X_WG, points) {
    // TODO: Finish this.  For now, I'll just pick out the x-z components
    return [X_WG[0], X_WG[1], X_WG[8], X_WG[9], X_WG[12], X_WG[13]];
  }

  function toColor(num) {
      num >>>= 0;
      var b = num & 0xFF,
          g = (num & 0xFF00) >>> 8,
          r = (num & 0xFF0000) >>> 16,
          a = 1; //( (num & 0xFF000000) >>> 24 ) / 255 ;
      return "rgba(" + [r, g, b, a].join(",") + ")";
  }

  function hashCode(s) {
    var h = 0, l = s.length, i = 0;
    if ( l > 0 )
      while (i < l)
        h = (h << 5) - h + s.charCodeAt(i++) | 0;
    return h;
  }

  function get_id(path_str) {
    let id = 'u' + hashCode(path_str);
    if (!(id in tree)) {
      // Create the node
      tree[id] = {};

      // Find it's parent
      let last_slash = path_str.lastIndexOf('/');
      if (last_slash > 0) {
        let parent = get_id(path_str.substring(0, last_slash));
        tree[id].X_WG = tree[parent].X_WG;
        tree[id].parent = parent;
      } else {
        // Use 4x4 identity matrix.
        tree[id].X_WG = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
    }
    return id;
  }

  function handle_command(cmd) {
    if (cmd.type == "set_transform") {
      console.log("set_transform", cmd);
      let id = get_id(cmd.path);

      let X_PG = cmd.matrix;
      if ("parent" in tree[id]) {
        X_WP = tree[tree[id].parent].X_WG;
        tree[id].X_WG = multiply_transform3d(X_WP, X_PG);
      } else {
        tree[id].X_WG = X_PG;
      }
      tree[id].X_PG = X_PG;
      
      // TODO: update descendents in tree.

    } else if (cmd.type == "set_object") {
      console.log("set_object", cmd);
      let id = get_id(cmd.path);

      // TODO: Parse actual UUIDs and match materials to geometries.
      // For now, I'll just process all the materials, and allow them to set the default color/opacity for this object.
      let color = "lightgray";
      let opacity = 1.0;
      cmd.object.materials.forEach(mat => {
        color = toColor(mat.color);
        opacity = mat.opacity;
      });

      // TODO: Remove existing geometries from svg.
      tree[id].geometries = [];
      
      cmd.object.geometries.forEach(geom => {
        if (geom.type == "BoxGeometry") {
          let x = geom.width/2.0*[-1, -1, 1, 1, -1, -1, 1, 1];
          let y = geom.depth/2.0*[-1, 1, -1, 1, -1, 1, -1, 1];
          let z = geom.height/2.0*[-1, -1, -1, -1, 1, 1, 1, 1];
          let pts = d3.range(8).map(
            function (i) { return [x[i], y[i], z[i]]; }
          );

          

          let poly = svg.append("polygon")
                   .attr("points", )
                   .attr("fill", color)
                   .attr("fill-opacity", opacity)
                   // TODO: don't hard code the width.
                   .attr("stroke-width", 0.01)
                   .attr("stroke", "black")
                   .data(pts);
          tree[id].geometries.push(poly);
        }
      });
    } else {
      console.log("cmd", cmd);
    }
  }

  var connection = new WebSocket(`ws://${location.host}`);
  console.log("connection:", connection);
  connection.binaryType = "arraybuffer";
  connection.onmessage = function(msg) {
      let decoded = msgpack.decode(new Uint8Array(msg.data));
      handle_command(decoded);
  }
  connection.onclose = function(evt) {
    console.log("onclose:", evt);
  }
</script>

</body></html>
